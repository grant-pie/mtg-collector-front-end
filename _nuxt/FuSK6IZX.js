import{E as a,y as i}from"./DdJi7br2.js";import{u as c}from"./DNdl8xi3.js";const d=a("deck",{state:()=>({userDecks:[],currentDeck:null,loading:!1,error:null}),actions:{async fetchUserDecks(s){const t=c(),o=i();if(t.token)try{this.loading=!0,this.error=null;const e=await $fetch(`${o.public.apiBaseUrl}/decks/user/${s}`,{method:"GET",headers:{Authorization:`Bearer ${t.token}`}});this.userDecks=e.decks||[]}catch(e){console.error("Error fetching user decks:",e),this.error=e.message||"Failed to fetch decks"}finally{this.loading=!1}},async fetchDeck(s){const t=c(),o=i();if(!t.token)return null;try{this.loading=!0,this.error=null;const e=await $fetch(`${o.public.apiBaseUrl}/decks/${s}`,{method:"GET",headers:{Authorization:`Bearer ${t.token}`}});return e.error?(this.error=e.error,null):(this.currentDeck=e.deck,e.deck)}catch(e){return console.error("Error fetching deck:",e),this.error=e.message||"Failed to fetch deck",null}finally{this.loading=!1}},async createDeck(s){var e;const t=c(),o=i();if(!t.token)return null;try{this.loading=!0,this.error=null;const r=await $fetch(`${o.public.apiBaseUrl}/decks`,{method:"POST",headers:{Authorization:`Bearer ${t.token}`,"Content-Type":"application/json"},body:s});return(e=t.user)!=null&&e.id&&await this.fetchUserDecks(t.user.id),r.deck}catch(r){return console.error("Error creating deck:",r),this.error=r.message||"Failed to create deck",null}finally{this.loading=!1}},async createDeckForUser(s,t){var r;const o=c(),e=i();if(!o.token)return null;try{this.loading=!0,this.error=null;const n=await $fetch(`${e.public.apiBaseUrl}/decks/user/${t}`,{method:"POST",headers:{Authorization:`Bearer ${o.token}`,"Content-Type":"application/json"},body:s});return(r=o.user)!=null&&r.id&&await this.fetchUserDecks(o.user.id),n.deck}catch(n){return console.error("Error creating deck:",n),this.error=n.message||"Failed to create deck",null}finally{this.loading=!1}},async updateDeck(s,t){var r;const o=c(),e=i();if(!o.token)return null;try{this.loading=!0,this.error=null;const n=await $fetch(`${e.public.apiBaseUrl}/decks/${s}`,{method:"PUT",headers:{Authorization:`Bearer ${o.token}`,"Content-Type":"application/json"},body:t});return this.currentDeck&&this.currentDeck.id===s&&(this.currentDeck=n.deck),(r=o.user)!=null&&r.id&&await this.fetchUserDecks(o.user.id),n.deck}catch(n){return console.error("Error updating deck:",n),this.error=n.message||"Failed to update deck",null}finally{this.loading=!1}},async removeDeck(s){var e;const t=c(),o=i();if(!t.token)return!1;try{return this.loading=!0,this.error=null,await $fetch(`${o.public.apiBaseUrl}/decks/${s}`,{method:"DELETE",headers:{Authorization:`Bearer ${t.token}`}}),this.currentDeck&&this.currentDeck.id===s&&(this.currentDeck=null),(e=t.user)!=null&&e.id&&await this.fetchUserDecks(t.user.id),!0}catch(r){return console.error("Error removing deck:",r),this.error=r.message||"Failed to remove deck",!1}finally{this.loading=!1}},async addUserCardToDeck(s,t){const o=c(),e=i();if(!o.token)return null;try{if(this.loading=!0,this.error=null,!s||!t)return this.error="Invalid deck or card ID",null;const r=await $fetch(`${e.public.apiBaseUrl}/decks/${s}/user-cards/${t}`,{method:"POST",headers:{Authorization:`Bearer ${o.token}`}});return!r||!r.deck?(this.error="Invalid response received",null):(this.currentDeck&&this.currentDeck.id===s&&(this.currentDeck=r.deck),r.deck)}catch(r){return console.error("Error adding card to deck:",r),this.error=r.message||"Failed to add card to deck",null}finally{this.loading=!1}},async addUserCardToDeckForUser(s,t,o){console.log("addUserCardToDeckForUser");const e=c(),r=i();if(!e.token)return null;try{this.loading=!0,this.error=null;const n=await $fetch(`${r.public.apiBaseUrl}/decks/user/${s}/${t}/user-cards`,{method:"POST",headers:{Authorization:`Bearer ${e.token}`,"Content-Type":"application/json"},body:{userCardId:o}});return this.currentDeck&&this.currentDeck.id===t&&(this.currentDeck=n.deck),n.deck}catch(n){return console.error("Error adding card to deck for user:",n),this.error=n.message||"Failed to add card to deck",null}finally{this.loading=!1}},async removeUserCardFromDeck(s,t){const o=c(),e=i();if(!o.token)return null;try{this.loading=!0,this.error=null;const r=await $fetch(`${e.public.apiBaseUrl}/decks/${s}/user-cards/${t}`,{method:"DELETE",headers:{Authorization:`Bearer ${o.token}`}});return this.currentDeck&&this.currentDeck.id===s&&(this.currentDeck=r.deck),r.deck}catch(r){return console.error("Error removing card from deck:",r),this.error=r.message||"Failed to remove card from deck",null}finally{this.loading=!1}}}});export{d as u};
